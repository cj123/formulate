package formulate

import (
	"errors"
	"net/url"
	"reflect"
)

// Validator is an interface that allows individual form fields to be validated as part of the Decode phase of a formulate
// form. Validators may be reused for multiple form fields.
type Validator interface {
	// Validate a given value. If the value passes your validation, return true, and no message.
	// If the value fails validation, return false and a validation message.
	Validate(value interface{}) (ok bool, message string)
	// TagName is the name of the validator. This must match the tag name used in the struct tag on the form field.
	// For example for a field with a tag: `validators:"email"`, the TagName returned here must be "email".
	TagName() string
}

// FormAwareValidator is a Validator that is aware of the full form that was posted. This can be used for
// validation that requires knowledge of other form values.
type FormAwareValidator interface {
	Validator

	SetForm(form url.Values)
}

// ErrFormFailedValidation is returned if any form fields did not pass validation.
var ErrFormFailedValidation = errors.New("formulate: form failed validation")

// ValidatorKey is used to match the Validator's TagName against that on a StructField.
type ValidatorKey string

// ValidationError is an error generated by the validation process. Each field may have multiple validation errors.
type ValidationError struct {
	// Error is the error message returned by the Validator.Validate method.
	Error string

	// Value is the value which failed validation.
	Value interface{}
}

// ValidationStore is a data store for the validation errors
type ValidationStore interface {
	// GetValidationErrors returns the errors for a given field.
	GetValidationErrors(field string) ([]ValidationError, error)

	// AddValidationError adds a validation error to the store
	AddValidationError(field string, validationError ValidationError) error

	// ClearValidationErrors removes all validation errors from the store
	ClearValidationErrors() error

	// SetFormValue saves the posted form value. It is only called if there are validation errors.
	SetFormValue(val interface{}) error

	// GetFormValue unmarshals the posted form value into the out interface.
	GetFormValue(out interface{}) error
}

type MemoryValidationStore struct {
	validationErrors map[string][]ValidationError

	val interface{}
}

func NewMemoryValidationStore() *MemoryValidationStore {
	return &MemoryValidationStore{
		validationErrors: make(map[string][]ValidationError),
	}
}

func (m *MemoryValidationStore) GetValidationErrors(field string) ([]ValidationError, error) {
	validationErrors, ok := m.validationErrors[field]

	if !ok {
		return nil, nil
	}

	return validationErrors, nil
}

func (m *MemoryValidationStore) AddValidationError(field string, validationError ValidationError) error {
	m.validationErrors[field] = append(m.validationErrors[field], validationError)

	return nil
}

func (m *MemoryValidationStore) ClearValidationErrors() error {
	m.validationErrors = make(map[string][]ValidationError)

	return nil
}

func (m *MemoryValidationStore) SetFormValue(val interface{}) error {
	m.val = val

	return nil
}

func (m *MemoryValidationStore) GetFormValue(out interface{}) error {
	if m.val == nil {
		return nil
	}

	v := reflect.ValueOf(out)

	if v.Kind() != reflect.Ptr {
		panic("formulate: GetFormValue target must be pointer")
	}

	savedVal := reflect.ValueOf(m.val)

	if savedVal.Kind() == reflect.Ptr {
		v.Elem().Set(savedVal.Elem())
	} else {
		v.Elem().Set(savedVal)
	}

	return nil
}
